// this is mostly the editor implemented by @SergioBenitez for graydon/rust-www
// plus small modifications to accommodate a "Reset" button
// also edited to have multiple code editors on a page.

// ECMAScript 6 Backwards compatability
if (typeof String.prototype.startsWith != 'function') {
  String.prototype.startsWith = function(str) {
    return this.slice(0, str.length) == str;
  };
}

// Regex for finding new lines
var newLineRegex = /(?:\r\n|\r|\n)/g;

// Status codes, because there are no enums in Javascript
var SUCCESS = 0;
var ERROR = 1;
var WARNING = 2;

// Error message to return when there's a server failure
var errMsg = "The server encountered an error while running the program.";

// Background colors for program result on success/error
var successColor = "#E2EEF6";
var errorColor = "#F6E2E2";
var warningColor = "#FFFBCB";

// Maximum length of a response before it has to be truncated
var MAX_RESPONSE_LENGTH = 50000;

ace.config.setModuleUrl('ace/mode/rust', '/gitbook/plugins/gitbook-plugin-rust-playpen/mode-rust.js');
var Range = ace.require('ace/range').Range;

// Create an Editor Class to be able to load multiple editors on a single page.
// The input tot he constructor is the parent element which contains the following
// classes:
//
// editor - ace editor gets initialized with this element
// reset-code - button to reset any code changes
// run-code - button to run the code in the associated editor
// result - container where the results are populated
//
var Editor = (function () {
    function getChild(parent, name) {
        return parent.getElementsByClassName(name)[0];
    }

    // Parses a problem message returning a list of ranges (row:col, row:col) where
    // problems in the code have occured.
    function parseProblems(lines) {
        var ranges = [];
        for (var i in lines) {
            var line = lines[i];
            if (line.startsWith("<anon>:") && line.indexOf(": ") !== -1) {
                var parts = line.split(/:\s?|\s+/, 5).slice(1, 5);
                var ip = parts.map(function(p) { return parseInt(p, 10) - 1; });
                ranges.push(new Range(ip[0], ip[1], ip[2], ip[3]));
            }
        }
        return ranges;
    }

    //
    // escapeHTML() borrowed from mustache.js:
    // https://github.com/janl/mustache.js/blob/master/mustache.js#L43
    //
    // via:
    // http://stackoverflow.com/questions/24816/escaping-html-strings-with-jquery/12034334#12034334
    //
    var entityMap = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': '&quot;',
        "'": '&#39;',
        "/": '&#x2F;'
    };

    function escapeHTML(unsafe) {
        return String(unsafe).replace(/[&<>"'\/]/g, function(s) {
            return entityMap[s];
        });
    }

    // Dispatches a XMLHttpRequest to the Rust playpen, running the program, and
    // issues a callback to `callback` with the result (or null on error)
    function runProgram(program, callback) {
        var req = new XMLHttpRequest();
        var data = JSON.stringify({
            version: "master",
            optimize: "0",
            code: program
        });

        // console.log("Sending", data);
        req.open('POST', "http://play.rust-lang.org/evaluate.json", true);
        req.onload = function(e) {
            if (req.readyState === 4 && req.status === 200) {
                var result = JSON.parse(req.response).result;

                // Need server support to get an accurate version of this.
                var statusCode = SUCCESS;
                if (result.indexOf("error:") !== -1) {
                    statusCode = ERROR;
                } else if (result.indexOf("warning:") !== -1) {
                    statusCode = WARNING;
                }

                callback(statusCode, result);
            } else {
                callback(false, null);
            }
        };

        req.onerror = function(e) {
            callback(false, null);
        };

        req.setRequestHeader("Content-Type", "application/json");
        req.send(data);
    }

    function Editor(container) {
        this.editorDiv = getChild(container, "editor");
        this.resetButton = getChild(container, "reset-code");
        this.runButton = getChild(container, "run-code");
        this.resultDiv = getChild(container, "result");
        this.markers = [];
        this.initialize();
    }

    Editor.prototype.initialize = function () {
        var self = this;
        this.editor = ace.edit(this.editorDiv);
        this.originalCode = this.editor.getValue();
        this.editor.setTheme("ace/theme/tomorrow");
        this.editor.getSession().setMode("ace/mode/rust");
        this.editor.setShowPrintMargin(false);
        this.editor.renderer.setShowGutter(false);
        this.editor.setHighlightActiveLine(false);
        this.editor.commands.addCommand({
            name: "run",
            bindKey: {
                win: "Ctrl-Enter",
                mac: "Ctrl-Enter"
            },
            exec: function() { self.executeCode(); }
        });
        // Set initial size to match initial content
        this.updateEditorHeight();

        this.editor.on('change', function() {
            self.updateEditorHeight();
        });

        // Highlight active line when focused
        this.editor.on('focus', function() {
            self.editor.setHighlightActiveLine(true);
        });
        // Don't when not
        this.editor.on('blur', function() {
            self.editor.setHighlightActiveLine(false);
        });

        // Registering handler for run button click
        this.runButton.addEventListener("click", function() {
            self.executeCode();
        });

        // Registering handler for reset button click
        this.resetButton.addEventListener("click", function(ev) {
            // Clear previous markers, if any
            self.markers.map(function(id) {
                self.editor.getSession().removeMarker(id);
            });

            self.editor.setValue(self.originalCode);
            self.resultDiv.style.display = "none";
        });

    };

    Editor.prototype.executeCode = function () {
        this.resultDiv.style.display = "block";
        this.resultDiv.innerHTML = "Running...";

        // Clear previous markers, if any
        this.markers.map(function(id) {
            this.editor.getSession().removeMarker(id);
        });

        var self = this;
        // Get the code, run the program
        runProgram(this.editor.getValue(), function (statusCode, message) {
            // Dispatch depending on result type
            if (message == null) {
                self.resultDiv.style.backgroundColor = errorColor;
                self.resultDiv.innerHTML = errMsg;
                return;
            }

            // Check the size of the message, shorten it if
            // it's too big to be appended to the DOM.
            if ( message.length > MAX_RESPONSE_LENGTH ) {
                message = message.slice(0, MAX_RESPONSE_LENGTH / 2)
                + '\n\n--- THIS RESULT HAS BEEN SHORTENED ---\n\n'
                + message.slice(-MAX_RESPONSE_LENGTH / 2);
            }

            if (statusCode == SUCCESS) {
                self.resultDiv.style.backgroundColor = successColor;
                self.resultDiv.innerHTML = escapeHTML(message);
            } else if (statusCode == WARNING) {
                self.resultDiv.style.backgroundColor = warningColor;
                self.handleProblem(message, "warning");
            } else {
                self.resultDiv.style.backgroundColor = errorColor;
                self.handleProblem(message, "error");
            }
        });
    };

    // Called on unsuccessful program run. Detects and prints problems (either
    // warnings or errors) in program output and highlights relevant lines and text
    // in the code.
    Editor.prototype.handleProblem = function (message, problem) {
        // Getting list of ranges with problems
        var lines = message.split(newLineRegex);

        // Cleaning up the message: keeps only relevant problem output
        var cleanMessage = lines.map(function(line) {
            if (line.startsWith("<anon>") || line.indexOf("^") !== -1) {
                var errIndex = line.indexOf(problem + ": ");
                if (errIndex !== -1) {
                    return line.slice(errIndex);
                }
                return "";
            }
            // Discard playpen messages, keep the rest
            if (line.startsWith("playpen:")) {
                return "";
            }
            return line;
        }).filter(function(line) {
            return line !== "";
        }).map(function(line) {
            return escapeHTML(line);
        }).join("<br />");

        // Setting message
        this.resultDiv.innerHTML = cleanMessage;

        // Highlighting the lines
        var ranges = parseProblems(lines);
        this.markers = ranges.map(function(range) {
            return this.editor.getSession().addMarker(range, "ace-" + problem + "-line", "fullLine", false);
        });

        // Highlighting the specific text
        this.markers = this.markers.concat(ranges.map(function(range) {
            return this.editor.getSession().addMarker(range, "ace-" + problem + "-text", "text", false);
        }));
    };

    // Changes the height of the editor to match its contents
    Editor.prototype.updateEditorHeight = function () {
        // http://stackoverflow.com/questions/11584061/
        var newHeight = this.editor.getSession().getScreenLength()
            * this.editor.renderer.lineHeight
            + this.editor.renderer.scrollBar.getWidth();

        this.editorDiv.style.height = Math.ceil(newHeight).toString() + "px";
        this.editor.resize();
    };

    return Editor;
})();

require(["gitbook"], function(gitbook) {
  gitbook.events.bind("page.change", function() {
    var codeBlocks = document.getElementsByClassName('active-code');
    for (var i = 0; i < codeBlocks.length; i++) {
        new Editor(codeBlocks[i]);
    };
  })
});
